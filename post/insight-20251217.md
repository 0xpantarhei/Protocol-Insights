# Protocol Insights #34

> Account Abstraction, Interop, Block Pipeline, Preconfs, MEV and Protocol

> Jason [@0xbbbb_eth](https://x.com/0xbbbb_eth)  
> Account Abstraction Developer  
> MEV Researcher  
> [ERC‑8065 (Zero Knowledge Token Wrapper)](https://ethereum-magicians.org/t/erc-8065-zero-knowledge-token-wrapper/26006) Author  
> Building [WalletAA](https://x.com/wallet_aam): [walletaa.com](https://walletaa.com) & [zk.walletaa.com](https://zk.walletaa.com)  
> Building [Panta Rhei](https://x.com/0xpantarhei)

## Account Abstraction

- [ERC-4337 EntryPont v0.9](https://github.com/eth-infinitism/account-abstraction/releases/tag/v0.9.0)

  - This version is ABI-compatible with v0.8 and v0.7, and does not require changes in Accounts and Paymasters, unless they want to use any of the new features.
  - Enable parallelizable Paymaster signing with paymasterSignature field.
  - Enable specifying the UserOperation validity range using block numbers.
  - Ignore the initCode without reverting if the Account already exists.
    - Enable use of a two-dimensional nonce in UserOperations with initCode.
  - Enable querying the current UserOperation hash during execution.
  - Better error messages.
  - Emit the address of the initialized EIP-7702 Account implementation delegation target.
  - Make BasePaymaster accept the owner as a parameter instead of using msg.sender

- [Supercharging Intents: Resource Locks](https://cyber.fund/content/RL)
  ![](https://images.ctfassets.net/bf97se5ff5r6/4vscudytaMHnD3yyVB9Uum/366aeb8c2c0a3c2824e668b0e00b0614/image__72_.png?w=2400)

  - Resource Locks function like a stamp machine, providing essential security guarantees for intent protocols, users, and solvers while eliminating certain trust assumptions present in existing intermediary-based protocols.
  - By removing these trust assumptions, intent systems can now provide synchronous composability with T+1 execution timing, where cross-chain transactions complete as quickly as single-chain operations. This eliminates the T through T+3 delay that characterizes current intent systems. However, users and solvers still have to trust the Resource Lock Machine.
  - When a Resource Lock protocol is cost-effective, fast, and has sufficient volume, it can deliver a cross-chain experience that feels identical to operating on a single chain, enabling true chain abstraction.
  - The different types of Resource Locks
    - Fully offchain Resource Locks
      ![](https://images.ctfassets.net/bf97se5ff5r6/101orABKpnWFKyE3X1v5Ds/568aa3c0cee20b3d673d78c14601fff4/image__74_.png?w=2400)
      - TEE
      - However, depending solely on TEEs creates censorship issues (TEE operators can decide to censor and block specific users) and liveness problems (if TEE stops working, there is no way to transfer your assets)
    - Semi-onchain (co-signer) Resource Locks
      ![](https://images.ctfassets.net/bf97se5ff5r6/3OiEltBeNOVPwo1thrNHe7/6ff13187339e24ef623d72c24c98a22d/image__75_.png?w=2400)
      - First signer belongs to the user (which can be a passkey, simple EOA, or any credential provable onchain).
      - The second signer comes from the TEE, providing the necessary Resource Lock guarantees for the system.
      - The user's signer can remove the second signer (which is the TEE signer) after a timelock period. The timelock is crucial, as it provides double-spend protection and other security guarantees to the solvers, and the ability to remove the TEE signer.
      - While this system appears more elegant in theory, it introduces practical complexities: developers must handle cross-chain state tracking, and there's additional overhead in both smart contract implementation and key management.
    - Fully onchain Resource Locks (a.k.a. escrow, or RL hooks)
      ![](https://images.ctfassets.net/bf97se5ff5r6/7cK4GIpKeNYbRof0wBOQKF/21e7d37efe42195b939975da456b53ea/image__76_.png?w=2400)
      - Fully onchain Resource Locks address the trust and sovereignty concerns of TEE-based approaches by moving all coordination onchain. This approach utilizes a subaccount structure, where users deposit assets into a separate contract, thereby keeping their main account unchanged.
      - However, this also has a drawback: users must deposit funds into the escrow contract for the system to function, which adds an extra step and compromises the desired user experience.

- [Introducing Transaction Monetization: Turn Every Transaction Into A Revenue Opportunity](https://x.com/gelatonetwork/status/1968736173855228313)
  - How it works:
    - Users pay in any token
    - You earn a % on each tx
    - Weekly USDC payouts
- [EIL: Trust minimized cross-L2 interop](https://ethresear.ch/t/eil-trust-minimized-cross-l2-interop/23437)
- [LIF: The Lean Intent Framework](https://x.com/0xbodu/status/1999159530614091817)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G75vdegXIAAs4Sl?format=jpg&name=medium)
  - Instead of contracts on the intent source and destination chains, we move all intent escrow and order validation logic to NEAR.
  - The user sends funds directly to an MPC controlled EOA and a solver directly fills the order on the destination chain via a direct transfer.
  - Lean vs Traditional OIF
    ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G75vLR5XIBEB8I9?format=jpg&name=medium)
- [ERC-8092: Associated Accounts](https://ethereum-magicians.org/t/erc-8092-associated-accounts/26858)
  - A way to publicly associate two accounts with arbitrary contextual data
  - ERC-8092 provides the infrastructure for:
    - Sub-account relationships: Link multiple addresses under a primary identity
    - Delegation schemes: Authorize specific accounts to act on behalf of another
    - Reputation aggregation: Consolidate activity and credentials across addresses
    - Cross-chain identity: Connect accounts on different blockchain networks
  - How it works
    - Associated Account Record (AAR)
    - Signed Association Record (SAR)
    - Both parties sign the EIP-712 hash of the association, creating a trustless proof of their relationship.
  - <https://www.erc8092.xyz/>

## Block Pipeline

- [Break Ethereum blocks down into synthetic 100ms sub-blocks on mainnet](https://x.com/ETHGasOfficial/status/1990033072163561908?s=20)
  - preconf + flashblocks
- [Announcing Pico Prism, the state-of-the-art zkVM for Ethereum real-time proving. 99.6% of blocks proven under 12 seconds, 6.9s average with 64 RTX 5090 GPUs.](https://x.com/brevis_zk/status/1978430670390133237?s=20)
- [Threshold Encrypted Mempools with mev-commit Preconfirmations](https://ethresear.ch/t/threshold-encrypted-mempools-with-mev-commit-preconfirmations/23588)
  - User encrypts via threshold cryptography
  - User submits encrypted transaction to sequencer
  - Sequencer submits encrypted bid to mev-commit bidder node
  - Bidder relays encrypted bid to builders (providers)
  - Builders evaluate and commit blind
  - Keypers validate commitment threshold, release keys
  - Builders decrypt and include transactions at top-of-block
  - Oracle verifies inclusion on L1
  - Oracle attests to mev-commit for rewards/slashing

## Protocol

- [Ethereum's Fusaka upgrade & Nethermind](https://x.com/ben_a_adams/status/1978111962174079107)
- [Ethereum Blobs](https://dune.com/hildobby/blobs)
- [EIP-7791: GAS2ETH opcode](https://eips.ethereum.org/EIPS/eip-7791)
  - Introduces a new opcode, `GAS2ETH`, to convert gas to ETH
  - Introducing the GAS2ETH opcode offers contract authors, as well as the tools they use, a new way to achieve their monetization objectives.
- [Modeling the Worst-Case Parallel Execution under EIP-7928](https://ethresear.ch/t/modeling-the-worst-case-parallel-execution-under-eip-7928/23418)
  - Ethereum’s EIP-7928: Block-Level Access Lists (BALs) opens the door to perfect parallelization of transactions.
  - But even with perfect independence, scheduling might matter. If we respect natural block order instead of reordering transactions, we could end up with idle cores waiting on a single large transaction.
- [EIP-7997: Deterministic Factory Predeploy](https://eips.ethereum.org/EIPS/eip-7997)
  - A minimal CREATE2 factory is inserted as a system contract in the precompile range, to enable deterministic deployments at identical addresses across EVM chains.
  - This benefits developer experience, user experience, and security, in particular for multi-chain and cross-chain applications, including account abstraction.
- [Perf engineering uncovered a propagation bottleneck in Prysm, traced to the BLS signature batching logic.](https://x.com/raulvk/status/1980945447683260770?s=20)
  - After tuning params, we hit optimality: negligible CPU impact, and a remarkable 6x reduction in per-hop propagation latency (30ms => 5ms).
  - [This PR decreases the amount of time that a gossipsub validation callback waits for a batch signature verification from 50ms to 5ms.](https://github.com/OffchainLabs/prysm/pull/15882)
- [State Expiry: In-protocol vs. Out-of-protocol](https://ethresear.ch/t/state-expiry-in-protocol-vs-out-of-protocol/23258)
  - “In-protocol” means expiry rules live in consensus. State objects carry minimal metadata which gets updated on state access (read, write, or both). If an object is expired at access time, it must be resurrected (typically via a tx) with attached witnesses. One example is EIP-7736 (leaf-level expiry on Verkle/Binary trie).
  - Out-of-protocol means no consensus change. Nodes can adopt a socially coordinated expiry policies (e.g. onchain or offchain registries). Nodes may drop state and expect users to bring their own proofs—but the chain does not force it.
- Consensus Attatcks
  - [One-epoch inactivation and Rifle attacks](https://ethresear.ch/t/one-epoch-inactivation-and-rifle-attacks/23351)
  - [Byzantine takeover attack](https://ethresear.ch/t/byzantine-takeover-attack/23352)
- [Block-Level Access Lists (EIP-7928)](https://x.com/uttam_singhk/status/1929873903435817321?s=20)
- [Compression-based state expiry](https://ethresear.ch/t/compression-based-state-expiry/23443)
  - There has been many proposals for state expiry over the year, and they all faltered because of the perceived (rightly so) complexity of the UX that they would entail.
  - The approach that is suggested in this document, is to gradually expire “cold” data by first moving them to some kind of cold storage where they would take less space, e.g. a flat file.
- [On delaying FOCIL inclusion](https://x.com/soispoke/status/1988250897437052934?s=20)
  - Background: [Ethereum Core Devs Confirm Glamsterdam Upgrade to Retain Trust Payments, Remove FOCIL](https://www.kucoin.com/news/flash/ethereum-core-devs-confirm-glamsterdam-upgrade-to-retain-trust-payments-remove-focil)
  - <https://x.com/nero_eth/status/2000492146080514274?s=20>
- [Visualize beacon chain slots and block proposals in real-time](https://lab.ethpandaops.io/ethereum/live)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G5zTOhhXcAAW6Ge?format=jpg&name=medium)
- [Minimmit: Fast Finality with Even Faster Blocks](https://x.com/_patrickogrady/status/1993340409138102482?s=20)
- [Unconditional payment of epbs](https://ethresear.ch/t/epbs-design-constraints/18728#h-32-unconditional-payment-10)
  - assuming the proposer and the builder agree upon a value for these rights, and the proposer acts honestly, he should receive payment regardless of the builder’s actions.
  - Other perspective:
    - <https://ethresear.ch/t/trustless-payments-right-vibe-more-trust/23531>
    - <https://ethresear.ch/t/trustless-payments/23635>
- [EIP-8046: FOCIL with ranked transactions (FOCILR)](https://x.com/weboftrees/status/1993781613843652618?s=20)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G6tVKh9WUAAusBW?format=jpg&name=900x900)
  - Some transactions are time-sensitive: what matters is inclusion within a set time frame. Sometimes that time frame is just a few blocks or even a single block.
  - FOCILR guarantees inclusion in the next block for a transaction offering a sufficient “ranking fee”.
  - if you are listed in an IL and the block is **full**, the builder cannot ignore your transaction, regardless of your priority fee. The builder must either include it, or otherwise only include transactions offering a higher ranking fee (while keeping the block full).
  - All transactions pay the same clearing fee, corresponding to the highest ranking fee offered by any IL transaction excluded from the block, and this fee is burned.
- [Fusaka Mainnet Prysm Incident](https://prysm.offchainlabs.com/docs/misc/mainnet-postmortems/)
  - Prysm beacon nodes received attestations from nodes that were possibly out of sync with the network. These attestations referenced a block root from the previous epoch.
  - In order to validate these attestations, Prysm attempted to recreate a beacon state compatible with the out-of-sync node's view of the chain.
  - This resulted in multiple processing of past epoch blocks and expensive epoch transition recomputations, which led to the client hitting resource exhaustion limits and untimely responses to validator requests
- [Consensus of Tempo](https://x.com/_patrickogrady/status/1998468195867570253?s=20)
  - In each round of consensus, Tempo validators emit a set of BLS12-381 threshold signatures that can be verified against a static network key (maintained across validator set changes)

## Rollup

- [EIP-8079: Native rollups](https://eips.ethereum.org/EIPS/eip-8079)

  - Expose Ethereum's STF as a precompile for rollups to use

- [Lazy bridging or Just in Time Bridging: Composability and Capital Efficiency](https://x.com/0xJaehaerys/status/1962576166533112176)

  - This model proposes a separation of capital's location from its utility. Assets can remain in the safest environment of all—L1—while their value is projected onto a high-performance L2 via a cryptographic proof.
  - This approach is notable because it frames Ethereum L1 as a foundational balance sheet for assets, while L2s become specialized execution surfaces.
  - The mechanism consists of four distinct steps:
    - Lock on L1: A user deposits assets—for example, ETH, stETH, or even DeFi vault positions like those from Morpho—into a purpose-built Escrow smart contract on Ethereum.
    - Credit on L2: After the deposit transaction achieves finality on L1, a ZK-proof of this lock event is generated. The L2 application (e.g., Lighter) verifies this proof and authorizes margin for the user's account.
    - Liquidation on L2: If a user's position violates the maintenance margin threshold, the L2's internal logic executes a liquidation and generates a new, outbound cryptographic proof: a proof-of-liquidation.
    - Settlement on L1: This proof-of-liquidation is submitted to the Escrow contract back on L1. Upon verification, it executes a forced ownership transfer, moving the user's locked collateral to a liquidator or an insurance fund.
    - Some perspective
      - It’s easy to see that this process isn’t fundamentally different from classical L1<>L2 native bridging: both lock L1 assets in a smart contract, both create a mapping/credit of those locked assets on L2, and both restrict L1 withdrawals based on L2 state.

- Bridgeless Ethereum

  - [Bridgeless Ethereum (I): Based Orderbook](https://paragraph.com/@luban-2/bridgeless-ethereum-i-based-orderbook)

    - The real unlock by bridgeless collateralization is yield-bearing-L1-native collateral assets. But have to find a way to reconcile fast L2 trading with slow L1 liquidation and price update, when exotic collaterals themselves are already hard enough to handle.
    - Based Orderbook: At its core is an onchain orderbook living as an Ethereum based rollup (the based orderbook itself), an L1 money market, and synchronous composability between the two.
      - Deposit: the user locks assets in the L2 bridge contract on L1 and notifies the sequencer; the sequencer instantly produces an L2 batch crediting the deposit; both the deposit tx and the batch are submitted in the same L1 slot; the batch is valid only if the deposit executes, ensuring same-slot crediting without unbacked L2 balances.
      - Withdrawal: the user initiates withdrawal on L2; the sequencer instantly produces a batch containing it; the batch is settled to L1; the L1 bridge contract verifies the proof and releases assets in the same slot; the release is valid only if the withdrawal settles.
      - Two reqiurements
        - Prove and settle L2 state within one L1 slot. While ZK real-time proving is advancing fast, TEEs still look more practical today.
        - Control ordering of L1 txs and L2 settlement. L1 deposit/withdrawal and L2 settlement must follow each other in the correct order in the same block. This is where basedness matters — unified L1<>L2 transaction ordering.
      - The perp DEX running on the Based Orderbook doesn’t need to natively support any collatrals other than stablecoin(s). Exotic assets are enabled instead by an L1 lending protocol.

  - [Bridgeless Ethereum (II): Unified Margin](https://paragraph.com/@luban-2/bridgeless-ethereum-ii-unified-margin)
    - Practically, UMBO spins up an smart contract account for each user so they can interact with rollup apps (for example, a perp DEX) while enjoying portfolio margin that includes their L1 deposits. Using Ethereum with UMBO will feel different, and better.

- [EthStorage Mainnet Alpha is live on Ethereum!](https://x.com/EthStorage/status/1977920558353486295)
  - The EthStorage network consists of two main components:
    - A storage contract deployed on the Ethereum L1 responsible for on-chain fee distribution and Proof of Storage verification.
    - An L2 storage network composed by es-nodes, responsible for off-chain data storage replicas and prove via continuous DA sampling.
- [Building Flashblocks with rblib](https://x.com/0xOptimus/status/1976310168292938057)

  - In this article, I will explain what rblib is, walk you through the core concepts of rblib and show you can use it to construct a block building pipelines for building Flashblocks.

- [t1’s Vision Litepaper](https://x.com/t1protocol/status/1987928321603367318?s=20)

  - t1 is the first interop rollup designed to fix fragmentation and composability challenges in scaling Ethereum.
  - The design achieving real-time interop among the @ethereum and existing rollups (incl. incumbents like @arbitrum & @base)—without requiring their permission.
  - We’re talking pragmatic composability via TEEs + crypto-economic security + ZK checkpoints.

- [I think it’s ok to allow stage 1 rollups shorter withdrawal windows (1-2 days), but we should be more conservative on stage 2](https://ethereum-magicians.org/t/i-think-its-ok-to-allow-stage-1-rollups-shorter-withdrawal-windows-1-2-days-but-we-should-be-more-conservative-on-stage-2/26392)
  - A stage 1 rollup can already be hacked if 75% of the security council get hacked. A 51% censorship attack on Ethereum is already an extreme situation, similarly extreme to 75% of a security council being hacked. Hence, for rollups that already accept stage 1 assumptions, the somewhat weaker properties of a 1-2 day window seem fine.
  - For a stage 2 rollup, the goal is to achieve true Ethereum-equivalent security. Hence, we do want to be 51% attack resistant, because Ethereum itself is 51% attack resistant (in the sense that if you hold ETH on L1, you keep that ETH even if a 51% attack happens; an attacker cannot make invalid state transitions happen). So we want the 7 day delay on any optimistic components.

## Others

- [ERC‑8065 (Zero Knowledge Token Wrapper)](https://ethereum-magicians.org/t/erc-8065-zero-knowledge-token-wrapper/26006)
- [awesome-eip7503](https://github.com/keyvank/awesome-eip7503)
- [x402](https://x.com/tinyxiong_eth/status/1980542373018103863?s=20)
  - [ERC-3009](https://eips.ethereum.org/EIPS/eip-3009) Token
  - <https://github.com/coinbase/x402>
    ![](https://raw.githubusercontent.com/coinbase/x402/refs/heads/main/static/flow.png)
  - <https://www.youtube.com/watch?v=iaIxRxvp9Vk&t=681s>
- [x402 V2](https://x.com/programmer/status/1999171014249578546?s=20)
  - Hook
  - Session
- [Agentic commerce = agent discovery + multi-agent communication + verifiable computation](https://x.com/soubhik_deb/status/1982823993645445359?s=20)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G4RnftXWAAAKl-Y?format=jpg&name=medium)
- [Succinct's Private Proving](https://x.com/SuccinctLabs/status/1975989782200320231?s=20)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G2werb5awAADF4w?format=jpg&name=medium)
  - privacy-preserving proof generation with the power of the Succinct Prover Network.
  - Previously, proofs on the Succinct Prover Network were public. With Private Proving, developers can generate proofs inside a trusted execution environment (TEE).
- [what @RAILGUN_Project is](https://x.com/binji_x/status/1977422543180148825?s=20)

  - private balances and transfers
  - private defi actions
  - zk-Proofs for compliance (institutions will love this)
  - self-custodial and onchain

- [Intel and AMD trusted enclaves, a foundation for network security, fall to physical attacks](https://arstechnica.com/security/2025/09/intel-and-amd-trusted-enclaves-the-backbone-of-network-security-fall-to-physical-attacks/)
  - The worse part is that this wasn’t the fault of the TEE protocols, it’s the fault of Intel who messed up their cryptographic implementation and ended up having deterministic memory encryption. And Intel wont fix it because it’s outside of the scope of their threat model.
  - There is no fix for this. The only “mitigation” is to not allow untrusted people to run a node or force them to use a cloud provider.
- [Breaking TDX, SGX, SEV and even Nvidia TEEs through DDR5](https://x.com/DanielGenkin/status/1983218858572788126?s=20)
- [详细解析 Kohaku 的端到端隐私解决方案和用户体验](https://chainfeeds.substack.com/p/kohaku?utm_source=substack&publication_id=933000&post_id=175769558&utm_medium=email&utm_content=share&utm_campaign=email-share&isFreemail=true&r=1sqem4&triedRedirect=true)

  - Kohaku is not aiming to build a mass-market consumer wallet. Instead, it provides composable privacy and security building blocks for different wallet teams, which can be integrated either fully or partially in a modular, plug-in–style manner.
  - The initial release focuses primarily on privacy features, with the reference wallet being a browser extension forked from Ambire. The team has clearly stated a mainnet-first strategy, with gradual support for L2s, while paying particular attention to fast withdrawal capabilities.

- [深入 EVM 交易模拟](https://x.com/tinyxiong_eth/status/1983823794910478393?s=20)
  - snapshots
  - apis
    - eth_estimateGas
      - internal ETH transfer ❌
    - trace_call
    - trace_transaction
    - debug_traceTransaction
    - debug_traceCall
  - Anvil --fork
- [Kohaku Roadmap](https://notes.ethereum.org/@niard/KohakuRoadmap)
- [ERC-8042: Diamond Storage](https://eips.ethereum.org/EIPS/eip-8042)
  - Define storage locations for structs using human-readable, meaningful strings.
- [AI traders](https://nof1.ai/leaderboard)
- [SIMD-0337 introduces block markers, paving the way for Fast Leader Handover in Alpenglow.](https://x.com/anza_xyz/status/1979199002177642500?s=20)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G3eGVnDWMAEEr9c?format=png&name=medium)
  - This enables leaders to optimistically build blocks on tentative parents, minimizing delay by changing leaders. Block production starts ~120ms earlier, improving IBRL by ~7.5%
- [SIMD-0298: Bank Hash in Footer](https://x.com/anza_xyz/status/1982825913537708284?s=20)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G4Rog9bXcAA7wJr?format=jpg&name=medium)
  - Before: In Alpenglow, validators vote on block_id instead of bank_hash. Without another mechanism, runtime bugs that alter state could go unnoticed. The footer preserves consensus on runtime results by ensuring all validators agree on the same post-execution state.
  - After: The feature activates before Alpenglow to preserve safety as execution and consensus evolve. Block producers include the hash, validators verify it matches their execution results. Mismatches mean the block gets skipped and prevents state divergence.
- [ve(3,3)](https://x.com/blockTVBee/status/1980934036232327551?t=spljo6WnG607_Ipp_UMQJA&s=09)
  ![](https://images.weserv.nl/?url=https://pbs.twimg.com/media/G325w-uXAAAOZoJ?format=png&name=medium)
- [1inch Aqua](https://github.com/1inch/aqua)
  - Traditional DeFi protocols fragment liquidity by locking it in isolated pools. Aqua solves this through a registry-based allowance system where liquidity providers maintain a single token approval while distributing virtual balances across multiple strategies.
  - Traditional AMM Pools
    - Liquidity fragmented across multiple isolated pools
    - Capital ($$) locked in pools
  - Aqua Protocol
    - Shared liquidity via AQUA virtual balances
    - Capital ($$) stays in wallet
  - Key Benefits
    - Unified Liquidity: Single approval enables participation in unlimited strategies
    - Capital Efficiency: Share liquidity across protocols without redeployment
    - Granular Control: Per-strategy balance management
    - No Custody: Tokens remain in LP wallets, only virtual balances tracked
- [Transaction Latency Simulator](https://www.txsim.com/)
  - Visualize real-time RPC latency when sending transactions across different chains
- [The Protocol Fee Discount Auction](https://moallemi.com/ciamac/papers/uniswap-pfda-2025.pdf)
  - Bidders compete in an auction to win the right to submit transactions without paying protocol fees during a specified time window (e.g., over a certain number of blocks).
  - The auction proceeds accrue to the protocol (for example, they may be used for token burning).
  - The winning bidder can conduct arbitrage at a lower cost, enabling the capture of small price discrepancies that would otherwise be unprofitable due to high fees.
- [build a trustless gas rebate program for uniswap v4 routers](https://x.com/brevis_zk/status/1981692217761943779?s=20)
  - Routers routes orders through Uniswap v4 hooked pools
  - Routers use Brevis to calculate gas costs off-chain
  - Generates ZK proof verifying the calculation and input
  - Routers claim rebates on-chain with the proof
- [The Upbit hacker is laundering funds through Railgun and has passed their "ZK proof of innocence'"](https://x.com/dethective/status/1994397800847589736?s=20)
- [ZK Secret Santa Protocol](https://ethresear.ch/t/zk-secret-santa-protocol/23582)
- [CREATE4](https://x.com/Agusx1211/status/1993272341791437193?s=20)
  - CREATE4 lets you counterfactually define different bytecodes for each network, while deploying to the same address
  - this way you can deploy the same contract, but optimized to the corresponding L1/L2/L3
- [Continuous Clearing Auctions: Bootstrapping Liquidity on Uniswap v4](https://blog.uniswap.org/continuous-clearing-auctions)
  - Targets
    - Onchain-native market creation. The entire auction runs onchain, with pricing, bidding, and settlement happening transparently. No gatekeepers or offchain deals.
    - Fair, gradual price discovery. Supply is distributed over time through a continuous clearing process. This incentivizes bidding early, reduces sniping, limits volatility, and helps the market converge toward a fair value.
    - Automatic liquidity seeding on Uniswap v4. When the auction ends, proceeds automatically create a Uniswap v4 pool at the discovered price, deepening liquidity.
  - How it works
    - Setting up the auction
    - Placing bids
      - Users then submit bids, specifying a maximum price and a total spend.
      - Each bid is automatically spread across the remaining blocks of the auction, using the same max price for every split.
      - A bid only fills if the block’s clearing price is at or below the bidder’s limit.
    - Finding a price
      - At the end of each block, the protocol sets a single market-clearing price
      - Everyone who fills in that block pays the same price.
  - Result
    - As more bids come in and supply per block stays pre-set, clearing prices stay the same or trend upward.
    - Early bidders tend to get a better average price since a larger portion of their bid can fill in earlier, cheaper blocks.
